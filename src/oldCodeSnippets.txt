
//TEST ENCODING/DECODING
	/*
	int numTests = 10000;
	vector<string> invalidinstructions;
	vector<string> validinstructions;
	vector<pair<Instruction, Instruction>> invalidArgumentInstructions;
	time_t start;
	time(&start);
	for(int i=0; i<numTests; i++){
		int instr = rand() * (((rand() % 2) == 0)? 1 : -1);

		Instruction nextPtr, loopPtr = d.buildInstruction(instr);
		if(loopPtr.getInstructionData() != NULL){

			Instruction nextPtr = e.buildInstruction(loopPtr.getAsmString());
			if(nextPtr.getInstructionData() != NULL){
				bool invalidEncode = false;
				invalidEncode |= loopPtr.getBin() != nextPtr.getBin();
				bool invalidArgumentValues = false;
				for(int argValTestIterator = 0; argValTestIterator<NUMBER_OF_PARAMETERS; argValTestIterator++){
					invalidArgumentValues |= loopPtr.getArgumentValue(argValTestIterator) != nextPtr.getArgumentValue(argValTestIterator);
				}
				if(invalidArgumentValues){
					pair<Instruction, Instruction> tmp;
					tmp.first = loopPtr;
					tmp.second = nextPtr;
					invalidArgumentInstructions.push_back(tmp);
				}

				if(invalidEncode){
					bool chk = true;
					for(unsigned int n=0; n<invalidinstructions.size(); n++){
						if(nextPtr.getInstructionData()->getName() == invalidinstructions[n]){
							chk = false;
							break;
						}
					}
					if(chk){
						invalidinstructions.push_back(nextPtr.getInstructionData()->getName());
					}
				}else{
					bool chk = true;
					for(unsigned int n=0; n<validinstructions.size(); n++){
						if(nextPtr.getInstructionData()->getName() == validinstructions[n]){
							chk = false;
							break;
						}
					}
					if(chk){
						validinstructions.push_back(nextPtr.getInstructionData()->getName());
					}	
				}
			}
		}
	}
	time_t end;
	time(&end);
	time_t time = end - start;
	cout << "Time: " << time << '\n';
	cout << "numTests: " << numTests << '\n';
	cout << "Time per: " << (float)(time) / (float)(numTests);
	*/












//TEST MEMORY STORE/LOAD
	/*
	
	vector<pair<virtualAddr, uint32_t>> junkValues;
	virtualAddr randVal = 1;
	for(int i=0; i<100000; i++){
		pair<virtualAddr, uint32_t> tmpPair;

		randVal += sizeof(tmpPair.first) + (rand() % 20);
		if(!(rand() % 100)){randVal += 1000;}
		
		tmpPair.first = randVal;
		tmpPair.second = rand();
		junkValues.push_back(tmpPair);
	}
	cout <<  "Memory range: [" << "0x" << std::setw(8) << std::setfill('0') << std::hex <<junkValues[0].first << ", " << "0x" << std::setw(8) << std::setfill('0') << std::hex <<junkValues[junkValues.size() - 1].first << ']' << '\n';

	int dkfjasdfsdf = 1;


	for(int i=0; i<junkValues.size(); i++){
		uint32_t tmpValue = junkValues[i].second;
		vm.writeToVirtualMemorySpace(junkValues[i].first, sizeof(uint32_t), &tmpValue);
	}


	int asdkfjads = 2;
	
	
	vector<uint32_t> readValues;
	for(int i=0; i<junkValues.size(); i++){
		virtualAddr addr = junkValues[i].first;
		uint32_t* tmpValue = (uint32_t*)vm.readVirtualMemorySpaceToHeap(addr, sizeof(uint32_t));
		uint32_t readValue = *tmpValue;
		uint32_t writtenValue = junkValues[i].second;
		readValues.push_back(readValue);
		if(readValue != writtenValue){
			virtualAddr pageNum = VirtualMemoryPageTable::calculatePageNumber(addr);
			virtualAddr pageOffset = VirtualMemoryPage::calculatePageOffset(addr);
			char pipe = 200;
			cout << std::dec << i << " addr: " << "0x" << std::setw(8) << std::setfill('0') << std::hex << addr << "\tpageNum: " << "0x" << std::setw(8) << std::setfill('0') << std::hex << pageNum << "\tpageOffset: 0x" << std::hex << pageOffset << '\n';
			cout << pipe << "----------> written:" << std::dec << writtenValue << "\tread:" << std::dec << readValue << '\n';;
		}
		delete tmpValue;
	}


	int x = 1;
	
	
	*/